(function(global){const kitmodule=global.kitmodule||(global.kitmodule={}),{reactive:kitReactive,directive:kitDirective,expression:kitExpression,compile:kitCompile}=kitmodule;function KitComponent(element,options={},config={}){const{name,prefix,attribute}=config;this.$attribute=attribute,this.$name=name,this.$prefix=prefix,element._kits||=new Set,element._kits.add(name),this.$element=element,this._exprs=new Map,this._events=[];var{state,methods,derived}=normalizeOptions(options);if(this.$dataset=extractDataset(element,name,prefix),this.$dataset.hasOwnProperty("state")){var stateData=this._parseExpr(this.$dataset.state);if(stateData&&typeof stateData=="object"){for(const key in stateData)stateData[key]=this._evaluator(stateData[key]);state={...state,...stateData}}}for(const key in methods)typeof methods[key]=="function"&&(methods[key]=methods[key].bind(this),this[key]=methods[key]);this._methods=methods;const{reactive,effect,computed,watch,stop}=kitReactive();this.$state=reactive(state),this.$effect=effect,this.$wacth=watch,this.$computed=computed;for(const key in state)Object.defineProperty(this,key,{get:()=>this.$state[key],set:value=>{this.$state[key]=value}});for(const key in derived){const desc=derived[key],target=desc.value||desc.get;typeof target=="function"&&this.$effect(()=>{this.$state[key]=target.call(this.$state)})}this.$alias=this.$dataset.alias,this._directives=kitDirective(this),this._destroyed=!1,this._bindEvents(),this._render()}KitComponent.prototype._render=function(){if(this._destroyed)return;const selector=Object.keys(this._directives).map(dir=>this.$selector(dir)).join(", ");let nodes=Array.from(this.$element.querySelectorAll(selector));Object.keys(this.$dataset).some(key=>key in this._directives)&&nodes.push(this.$element),nodes.forEach(el=>{for(const[directive,handler]of Object.entries(this._directives)){const attr=this.$directive(directive),expr=el.getAttribute(attr);expr!=null&&handler(el,expr)}})},KitComponent.prototype.$directive=function(dir){return[this.$prefix,this.$name,dir].filter(Boolean).join("-")},KitComponent.prototype.$selector=function(dir,target){const attr=this.$directive(dir);return target?`[${attr}=${target}]`:`[${attr}]`},KitComponent.prototype._parseExpr=function(expr){let result=kitExpression(expr);return Object.keys(result).length===0?expr:result},KitComponent.prototype._evaluator=function(expr,event=null,node=null,extra={}){try{if(!expr)return;let cacheKey=expr.trim();this._exprs.has(cacheKey)||this._exprs.set(cacheKey,kitCompile(cacheKey));const fn=this._exprs.get(cacheKey);return typeof fn.assign=="function"&&/^[\w.]+\s*=/.test(cacheKey)?fn.assign(this.$state,extra.value,{this:node,event,...this._methods}):fn(this.$state,{this:node,event,...this._methods})}catch(err){return console.error("[kitComponent._eval] Error evaluating expression:",expr,err),0[0]}},KitComponent.prototype._bindEvents=function(){const directive=this.$directive("event"),selector=this.$selector("event");let nodes=Array.from(this.$element.querySelectorAll(selector));this.$dataset.hasOwnProperty("event")&&nodes.push(this.$element),nodes.forEach(node=>{let raw=node.getAttribute(directive);if(!raw)return;const exprs=this._parseExpr(raw);if(!exprs)return;if(typeof exprs=="object"){for(const[eventer,expr]of Object.entries(exprs))switch(eventer){case"click-outside":const selector=this.$selector("ignore","outside"),ignores=this.$element.querySelectorAll(selector),exceptions=ignores.length>0?ignores:nodes;this._handleOutside(expr,exceptions,node);break;case"intersect":case"leave":case"appear":case"exit":this._handleIntersect(expr,eventer,node);break;default:const handler=e=>this._evaluator(expr,e,node,{}),{event,timer}=parseEvents(eventer);if(timer==0){node.addEventListener(event,handler),this._events.push({node,event,handler});break}const finalHandler=debounce(handler,timer,this);node.addEventListener(event,finalHandler),this._events.push({node,event,handler:finalHandler});break}return}if(typeof exprs=="string"){let event;const tag=node.tagName.toLowerCase();switch(tag){default:event="click"}const handler=e=>this._evaluator(exprs,e,node);node.addEventListener(event,handler),this._events.push({node,event,handler});return}})},KitComponent.prototype._handleOutside=function(expr,exceptions=[],node){const whitelist=Array.from(new Set(exceptions)),handler=e=>{const target=e.target,isInside=whitelist.some(el=>el.contains(target));if(isInside)return;this._evaluator(expr,e,node)};document.addEventListener("click",handler),this._events.push({node:document,event:"click",handler})},KitComponent.prototype._handleIntersect=function(expr,type,el){if(!el)return;const mapType={appear:{event:"enter",once:!0},intersect:{event:"enter",once:!1},leave:{event:"leave",once:!1},exit:{event:"leave",once:!0}},typeInfo=mapType[type];if(!typeInfo)return;const observer=new IntersectionObserver((entries,obs)=>{entries.forEach(entry=>{const isEnter=entry.isIntersecting,isLeave=!entry.isIntersecting;(typeInfo.event==="enter"&&isEnter||typeInfo.event==="leave"&&isLeave)&&(this._evaluator(expr,null,el),typeInfo.once&&obs.unobserve(el))})},{threshold:0});observer.observe(el),this._events.push({node:el,event:"intersect",handler:observer})},KitComponent.prototype._kitDestroy=function(){if(this._destroyed)return;this._destroyed=!0,this._events.forEach(({node,event,handler})=>{switch(event){case"intersect":handler.disconnect?.();break;default:node.removeEventListener(event,handler)}}),this._events=[],typeof this.$effect.cleanup=="function"&&this.$effect.cleanup(),this.$element._kits?.delete(this.$name),this.$element=null,this.$state=null,this._methods=null,this._directives=null,this.$dataset=null};function debounce(fn,delay,thisTarget){let timer=null;return function(...args){clearTimeout(timer),timer=setTimeout(()=>fn.apply(thisTarget,args),delay)}}function normalizeOptions(options){return"state"in options||"methods"in options||"computed"in options?{state:JSON.parse(JSON.stringify(options.state)),methods:Object.assign({},options.methods),derived:Object.getOwnPropertyDescriptors(options.computed||{})}:parseOptions(options)}function parseOptions(options){var state={},methods={},derived={};const descriptors=Object.getOwnPropertyDescriptors(options);for(const key in descriptors){const desc=descriptors[key];if(typeof descriptors[key].get=="function"){derived[key]=desc;continue}if(typeof descriptors[key].value=="function"){methods[key]=desc.value;continue}state[key]=desc.value}return{state,methods,derived}}function extractDataset(element,name,prefix){if(!element)return null;const result={},startAttr=prefix?[prefix,name].join("-"):name;for(const attr of element.getAttributeNames())if(attr.startsWith(startAttr+"-")){const shortKey=attr.slice((startAttr+"-").length),shortKeySplit=shortKey.split("-"),finalKey=shortKeySplit.map((part,i)=>i===0?part:part.charAt(0).toUpperCase()+part.slice(1)).join("");result[finalKey]=element.getAttribute(attr)}return result}function parseEvents(eventText){if(!eventText.endsWith(")"))return{event:eventText,timer:0};const match=eventText.match(/^(\w+)\((\d+)\)$/);return match?{event:match[1],timer:parseInt(match[2])}:{event:eventText,timer:0}}kitmodule.component=KitComponent})(typeof window!="undefined"?window:globalThis)