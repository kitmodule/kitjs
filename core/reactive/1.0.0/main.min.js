(function(global){const kitmodule=global.kitmodule||(global.kitmodule={});function kitReactive(){const bucket=new WeakMap;let activeEffect=null;const jobQueue=new Set;let isFlushing=!1;function schedule(job){jobQueue.add(job),isFlushing||(isFlushing=!0,Promise.resolve().then(()=>{jobQueue.forEach(fn=>fn()),jobQueue.clear(),isFlushing=!1}))}function track(target,key){if(!activeEffect)return;let depsMap=bucket.get(target);depsMap||(depsMap=new Map,bucket.set(target,depsMap));let deps=depsMap.get(key);deps||(deps=new Set,depsMap.set(key,deps)),deps.add(activeEffect),activeEffect.deps.push(deps)}function trigger(target,key){const depsMap=bucket.get(target);if(!depsMap)return;const deps=depsMap.get(key);if(!deps)return;const effectsToRun=new Set(deps);effectsToRun.forEach(effectFn=>{effectFn.scheduler?effectFn.scheduler(effectFn):effectFn()})}function cleanup(effectFn){for(const dep of effectFn.deps)dep.delete(effectFn);effectFn.deps.length=0}function effect(fn,options={}){const effectFn=()=>{cleanup(effectFn),activeEffect=effectFn;const result=fn();return activeEffect=null,result};return effectFn.deps=[],effectFn.scheduler=options.scheduler,options.lazy||effectFn(),effectFn}function reactive(obj,cache=new WeakMap){if(typeof obj!="object"||obj===null)return obj;if(cache.has(obj))return cache.get(obj);const proxy=new Proxy(obj,{get(target,key,receiver){const res=Reflect.get(target,key,receiver);return track(target,key),typeof res=="object"?reactive(res,cache):res},set(target,key,value,receiver){const oldVal=target[key],result=Reflect.set(target,key,value,receiver);return oldVal!==value&&trigger(target,key),result}});return cache.set(obj,proxy),proxy}function computed(getter){let value,dirty=!0;const runner=effect(getter,{lazy:!0,scheduler:()=>{dirty=!0,trigger(computedRef,"value")}}),computedRef={get value(){return dirty&&(value=runner(),dirty=!1),track(computedRef,"value"),value}};return computedRef}function watch(source,callback,options={}){let getter=typeof source=="function"?source:()=>source,oldValue,cleanupFn;function onCleanup(fn){cleanupFn=fn}const job=()=>{cleanupFn&&cleanupFn();const newValue=runner();callback(newValue,oldValue,onCleanup),oldValue=newValue},runner=effect(()=>getter(),{lazy:!0,scheduler:()=>schedule(job)});return options.immediate?job():oldValue=runner(),()=>cleanup(runner)}function stop(runner){cleanup(runner)}return{reactive,effect,computed,watch,stop}}kitmodule.reactive=kitReactive})(typeof window!="undefined"?window:globalThis)